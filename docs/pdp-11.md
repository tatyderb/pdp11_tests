# Техническое задание на создание эмулятора PDP-11
## Аргументы программы
Будем в дальнейшем считать, что pdp11 – это программа эмуляции. Вызывается со следующими аргументами:
    
    pdp11 –[q|r|R|p|s] pc filename

* `pc` — начальное значение `рс`.
* `filename` — название программы, которую будем исполнять на эмуляторе

Ключи:

* `-q` — вЫключить трассировку исполняемой программы
* `-r` — при трассировке показывать значение изменяемых регистров
* `-R` — при трассировке показывать значение ВСЕХ регистров
* `-p` — печатать `NZVC` флаги регистра `PSW`
* `-s` — пошаговый режим. Выполнение следующей команды происходит после нажатия клавиши.

## Архитектура эмулироемой ЭВМ

### Общая память
Машинное слово состоит из 2 байт. Байты и слова имеют единое адресное пространство. Байт с меньшим адресом лежит в младшем разряде. Машинные слова имеют адреса от 0 до 65534.

Заметим, что слов с нечетными адресами не существует.

### Регистры процессора

Машина имеет 8 регистров общего назначения (далее в документе мы будем обозначать их `R0..R7`). Обращение ко всем регистрам имеет одинаковый формат.

Регистр `R7` содержит адрес памяти, из которого будем считывать следующее машинное слово, иначе называется `PC` _(program counter)_. 

Регистр `R6` содержит адрес памяти, являющийся вершиной стека, иначе называется `SP` _(stack pointer)_.

### Моделирование работы центрального процессора, памяти и регистров

Будем считать, что для моделирования используются следующие массивы и переменные:
    
```cpp
    word mem[65534];	// массив, моделирующий RAM
    word reg[8];	// массив, моделирующий регистры
    pc, он же reg[7]
    sp, он же reg[6]
```    
Тогда основной цикл работы машины состоит из считывания очередной команды из памяти и ее исполнения:

```cpp
    while (1) {
    	word operation = mem[pc];	// считывание команды из памяти
    	pc += 2;
    	do_operation (operation);	// выполнение команды
    }
```
    
### Слово состояния процессора (PSW) 

Кроме регистров у процессора есть еще одно доступное слово, характеризующее состояние процессора. Выполнение некоторых команд может привести к изменению некоторых бит-флагов.

Из 16-битного слова состояния процессора (`Process State Word`) необходимо моделировать только 4 последних бита: флаги `N`, `Z`, `V`, `C`.

* `Z` – индикатор нуля, равен 1, если в результате выполнения операции получился ноль.
* `N` – индикатор отрицательного результата, равен 1, если в результате выполнения операции получилось отрицательное число.
* `C` – индикатор переноса.
* `V` – индикатор знакового переполнения.

ЦП обычно устанавливает `С` в 1, если произошел перенос из 15-го бита. Можно считать `С` не существующим "16-тым  битом".

`V` устанавливается в 1, если, например, при сложении положительных чисел получилось отрицательное число (в результате переполнения). Заметим, что при этом флаг `С=0`.

## Форматы операторов

Инструкции ассемблера могут иметь от 0 до 2 параметров. Например, команда `HALT` не имеет операндов (параметров), команда `INC` имеет один операнд, команда `MOV` – 2 операнда.

Поэтому выполнение машинной команды начинается с определения какую команду следует выполнять и с какими операндами. Для этого разделяют команду на код операции и ее операнды.

Команда `HALT` имеет код операции `000000` (в **восьмеричном** виде), не имеет операндов и располагается в одном машинном слове.

Команда `INC d` (увеличение на 1) имеет код `0052DD`, где биты `0052` отвечают за код операции, а в последних 6 битах, обозначеных `DD`, хранится информации об операнде (какое число увеличивать). В бинарном виде команда представляется как:

|Бит|_15_|_14_|_13_|_12_|_11_|_10_|_9_|_8_|_7_|_6_|_5_|_4_|_3_|_2_|_1_|_0_|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|Значение|0|0|0|0|1|0|1|0|1|0|_d_|_d_|_d_|_d_|_d_|_d_|

Эта команда увеличивает на 1 число, хранящееся по адресу, указанному в последних 6 битах. Подробнее о нахождении адреса написано в разделе "Режимы адресации".

Операнд некоторых команд может занимать 3 (`RTS`) или 8 бит (`BR`).

Команда с 2 операндами `MOV s, d` отводит под операнды 12 бит, а оставшиеся 4 идут на код операции:

|Бит|_15_|_14_|_13_|_12_|_11_|_10_|_9_|_8_|_7_|_6_|_5_|_4_|_3_|_2_|_1_|_0_|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|Значение|0|0|0|1|_s_|_s_|_s_|_s_|_s_|_s_|_d_|_d_|_d_|_d_|_d_|_d_|

Разбор каждого операнда производится отдельно. **Сначала разбирается первый операнд, потом – второй**.

Некоторые операции являются байтовыми. Они выполняются над байтом и адресуют байт памяти или номер регистра.

## Режимы адресации

6 бит на адресации источника (`s`) или приемника (`d`) разделяются на 3 бита номера режима (`m`) и 3 бита номера регистра (`r`): `mmmrrr `

Подробности в _Приложении 2_.

`op_adr` – адрес операнда, `op_val = mem[op_adr]` – значение операнда, `r` – регистр (`Rn`, `sp`, `pc`), `nn` – 16-битное число

2: тест: `mov (r4)+, (r4)+`

3pc: используется, например, при организации ввода

    DATAOUT = 0177566
    mov R0, @#DATAOUT

6pc: обращение по метке (тот же эффект, что и 3pc)

    answer: 	.BLKW
                MOV	R5, answer
                
## Ввод/вывод

Вывод на экран происходит через обращение к памяти. Запись ASCII-кода символа в байт с номером `0777566` (который называется регистр данных) приводит к выводу этого символа на экран. Однако, это устройство может быть не готово к отображению данных на экране (он собирается выводить один символ, а мы уже пишем по этому адресу следующий). Статус готовности устройства можно узнать из 7-го бита по адресу `0777564` (статусный регистр устройства вывода).

Эмулятор должен выводить символ из `0777566` на экран только после того, как был опрошен 7-ой бит по адресу `0777564`. Аналогичное поведение должно обеспечивать ввод с клавиатуры.

Аналогично устроен ввод с клавиатуры. ASCII-код введенного символа пишется в байт номер `0777562`, статусный регист расположен по адресу `0777560`.

## Формат исполняемого файла

Исполняемый файл состоит из 1 или нескольких блоков, организованных следующим образом (все числа записаны в шестнадцатеричной системе):

```
    addr    N
    byte0
    byte1
    …
    byteN-1
```
где
 
* `addr` – адрес начала расположения блока в памяти в восьмеричной системе
* `N` – сколько байт далее будет записано (hex)
* `byte0` .. `byteN-1` – байты (hex) 

## Трассировка

При трассировки (простой) должны выводиться следующие данные (как в листинге + флаги `NZVC` + вовлекаемые регистры, кроме `pc`):

UPD: **Значения вовлекаемых регистров до и после операции можно не печатать**

    002346: 012725 NZ--	mov #1024, (r5)+		r5=002000

При выводе всех регистров после выполнения каждой команды должна печататься строка (умещаясь в 80 символов):

    r0=000000 r1=000000 r2=000000 r3=000000 r4=000000 r5=000000 sp=000000 pc=001000

## Команды ассемблера

Бит 15 (обозначается ниже `b`)  показывает, работает эта инструкция со словами (`b=0`) или с байтами (`b=1`). Многие инструкции имеют только одну форму (например, `ADD`). 

### Инструкции без операндов

`0000000 – HALT` 

Останавливает выполнение программы

### Инструкции с двумя операндами

Имеют 2 операнда: источник и приемник. Операнды располагаются в инструкции так:

     |b|i|i|i|s|s|s|s|s|s|d|d|d|d|d|d|
     | |     |     :     |     :     |
     | | Op  |   Source  |    Dest   |
     
Знаковым расширением называют заполнение битов старшего байта значением знакового бита младшего байта.

`b 001 ssssss dddddd -- MOV/MOVB` Move Word/Byte 

`d = s`

Перемещает значение из источника в приемник

Если приемником является регистр, то значение пишется в младший байт регистра-приемника и происходит знаковое расширение.

`b 010 ssssss dddddd -- CMP/CMPB` Compare Word/Byte 
`d – s`
Вычитает приемник из источника и выставляет флаги состояния процессора. Ни источник, ни приемник не изменяются.

`b 011 ssssss dddddd -- BIT/BITB` Bit Test Word/Byte 
`d & s`
Совершает побитовое И над источником и приемником и выставляет флаги состояния процессора. Ни источник, ни приемник не изменяются.

`b 100 ssssss dddddd -- BIC/BICB` Bit Clear Word/Byte 
`d = (~s) & d`
Сбросить биты приемника по маске источника

`b 101 ssssss dddddd -- BIS/BISB` Bit Set Word/Byte 
`d = s | d`
Установить биты приемника по маске источника

`0 110 ssssss dddddd -- ADD` Add Word 
`1 110 ssssss dddddd -- SUB` Subtract Word 
`d = d + s`
`d = d – s`
Складывает/вычитает приемник и источник.

**Байтовая форма операций отсутствует.**

    |i|i|i|i|i|i|i|r|r|r|d|d|d|d|d|d|
    |             |  :  |     :     |
    | Operation   | Reg |  Destin   |

Arithmetic functions not supported by all implementations of the PDP-11 architecture.

|Mnemonic  | Opcode |NZVC|Description               |Notes        |
|:---------|:-------|:---|:-------------------------|:----        |
|`ADCb d`  |`B055DD`|****|Add Carry                 |d=d+C        |
|`ADD s,d` |`06SSDD`|****|Add                       |d=s+d        |
|`ASH  s,r`|`072RSS`|****|Arithmetic Shift          |r=r*2^s(EIS)#|
|`ASHC s,r`|`073RSS`|****|Arithmetic Shift Combined |(EIS)#       |
|`ASLb d`  |`B063DD`|****|Arithmetic Shift Left     |d=d*2        |
|`ASRb d`  |`B062DD`|****|Arithmetic Shift Right    |d=d/2        |
|`BCC  a`  |`1030XX`|----|Branch if Carry Clear     |If C=0       |
|`BCS  a`  |`1034XX`|----|Branch if Carry Set       |If C=1       |
|`BEQ  a`  |`0014XX`|----|Branch if Equal           |If Z=0       |
|`BGE  a`  |`0020XX`|----|Branch if Greater or Equal|If NxV=0     |
|`BGT  a`  |`0030XX`|----|Branch if Greater Than    |If Zv{NxV}=0 |
|`BICb s,d`|`B4SSDD`|**0-|Bit Clear                 |d=d&{~s}     |
|`BISb s,d`|`B5SSDD`|**0-|Bit Set (OR)              |d=dvs        |
|`BITb s,d`|`B3SSDD`|**0-|Bit Test (AND)            |d&s          |
|`BHI  a`  |`1010XX`|----|Branch if Higher          |If CvZ=0     |
|`BHIS a`  |`1030XX`|----|Branch if Higher or Same  |If C=0       |
|`BLE  a`  |`0034XX`|----|Branch if Less or Equal   |If Zv{NxV}=1 |
|`BLT  a`  |`0024XX`|----|Branch if Less Than       |If NxV=1     |
|`BLO  a`  |`1034XX`|----|Branch if Lower           |If C=1       |
|`BLOS a`  |`1014XX`|----|Branch if Lower or Same   |If CvZ=1     |
|`BMI  a`  |`1004XX`|----|Branch if Minus           |If N=1       |
|`BNE  a`  |`0010XX`|----|Branch if Not Equal       |If Z=1       |
|`BPL  a`  |`1000XX`|----|Branch if Plus            |If N=0       |
|`BR   a`  |`0004XX`|----|Branch                    |PC=PC+2*XX   |
|`BVC  a`  |`1020XX`|----|Branch if Overflow Clear  |If V=0       |
|`BVS  a`  |`1024XX`|----|Branch if Overflow Set    |If V=1       |
|`CALL d`  |`0047DD`|----|Call subroutine           |(= JSR PC,d) |
|`CCC`     |`000257`|0000|Clear all Condition Codes |{C,N,V,Z}=0  |
|`CLC`     |`000241`|---0|Clear Carry               |C=0          |
|`CLN`     |`000250`|0---|Clear Negative            |N=0          |
|`CLRb d`  |`B050DD`|0100|Clear                     |d=0          |
|`CLV`     |`000242`|--0-|Clear Overflow            |V=0          |
|`CLZ`     |`000244`|-0--|Clear Zero                |Z=0          |
|`CMPb s,d`|`B2SSDD`|****|Compare                   |s-d          |
|`COMb d`  |`B051DD`|**01|Complement                |d=~d         |
|`DECb d`  |`B053DD`|***-|Decrement                 |d=d-1        |
|`DIV  s,r`|`071RSS`|****|Divide                    |r=r/s  (EIS)#|
|`HALT`    |`000000`|----|Halt                      |             |
|`INCb d`  |`B052DD`|***-|Increment                 |d=d+1        |
|`JMP  d`  |`0001DD`|----|Jump                      |PC=d         |
|`JSR  r,d`|`004RDD`|----|Jump to Subroutine        |r=PC,PC=d    |
|`MOVb s,d`|`B1SSDD`|**0-|Move                      |d=s          |
|`MUL  s,r`|`070RSS`|**0*|Multiply                  |r=r*s  (EIS)#|
|`NEGb d`  |`B054DD`|****|Negate                    |d=-d         |
|`NOP`     |`000240`|----|No Operation              |             |
|`RETURN`  |`000207`|----|Return from subroutine    |(= RTS PC)   |
|`ROLb d`  |`B061DD`|****|Rotate Left               |d={C,d}<-    |
|`RORb d`  |`B060DD`|****|Rotate Right              |d=->{C,d}    |
|`RTS  r`  |`00020R`|----|Return from Subroutine    |PC=r,r=(SP)+ |
|`SBCb d`  |`B056DD`|****|Subtract Carry            |d=d-C        |
|`SCC`     |`000277`|1111|Set all Condition Codes   |{C,N,V,Z}=0  |
|`SEC`     |`000261`|---1|Set Carry                 |C=1          |
|`SEN`     |`000270`|1---|Set Negative              |N=1          |
|`SEV`     |`000262`|--1-|Set Overflow              |V=1          |
|`SEZ`     |`000264`|-1--|Set Zero                  |Z=1          |
|`SOB  r,a`|`077RNN`|----|Subtract One and Branch   |PC=PC-2*NN  #|
|`SUB  s,d`|`16SSDD`|****|Subtract                  |d=d-s        |
|`SWAB d`  |`0003DD`|**00|Swap Bytes                |             |
|`SXT  d`  |`0067DD`|-*0-|Sign Extend               |d=0 or -1   #|
|`TSTb d`  |`B055DD`|**00|Test                      |d            |
|`XOR  r,d`|`074RDD`|**0-|Exclusive OR              |d=dxr       #|
|          |        |    |                          |             |
|`BPT`     |`000003`|----|Breakpoint Trap           |Vector at 14 |
|`EMT  t`  |`1040TT`|----|Emulator Trap             |Vector at 30 |
|`FADD r`  |`07500R`|**00|Floating Add              |(FIS)#       |
|`FDIV r`  |`07503R`|**00|Floating Divide           |(FIS)#       |
|`FMUL r`  |`07502R`|**00|Floating Multiply         |(FIS)#       |
|`FSUB r`  |`07501R`|**00|Floating Subtract         |(FIS)#       |
|`IOT`     |`000004`|----|Input/Output Trap         |Vector at 20 |
|`MARK n`  |`0064NN`|----|Mark stack                |RTS aid  #   |
|`MFPD s`  |`1065SS`|**0-|Move From Previous Data   |#            |
|`MFPI s`  |`0065SS`|**0-|Move From Previous Instr. |#            |
|`MFPS d`  |`1067DD`|**0-|Move From Processor Status|d=PS<7:0>   #|
|`MTPD d`  |`1066DD`|**0-|Move To Previous Data     |#            |
|`MTPI d`  |`0066DD`|**0-|Move To Previous Instr.   |#            |
|`MTPS s`  |`1064SS`|****|Move To Processor Status  |PS<7:0>=s   #|
|`RESET`   |`000005`|----|Reset external bus        |             |
|`RTI`     |`000002`|----|Return from Interrupt     |{PC,PS}=(SP)+|
|`RTT`     |`000006`|----|Return from Trace trap    |No T trap   #|
|`SPL  n`  |`00023N`|----|Set Priority Level        |PS<7:5>=N   #|
|`TRAP t`  |`1044TT`|----|Trap                      |Vector at 34 |
|`WAIT`    |`000001`|----|Wait for interrupt        |             |
             
Условные обозначения:

|Символ|Значение|
|------|--------------------------------------------------------|
|B     |0 for word, 1 for byte (1 bit)                          |
|DD    |Destination field (6 bits)                              |
|N     |Number (3 bits)                                         |
|NN    |Number (6 bits)                                         |
|R     |Register (3 bits, R0-5/SP/PC)                           |
|SS    |Source field (6 bits)                                   |
|TT    |Number (8 bits)                                         |
|XX    |Offset (8 bits, -128 to +127)                           |
| -*01 |Флаг не изменяется/изменяется/очищается/устанавливается |


### Режимы адресации

| |режим |обозначение|название режима       |значение операнда             |
|-|------|-----------|----------------------|------------------------------|
|0|000rrr|`r`        |регистровый (register)|значение – содержимое регистра <br>`op_val = r`
|1|001rrr|`(r)` `@r` |косвенный регистровый (register deferred)|в регистре содержится адрес <br>`op_adr = r;`<br> `op_val = mem[r];`|
|2|010rrr|`(r)+ `    |автоувеличения (auto-increment)|в регистре содержится адрес, после доступа к регистру его содержимое увеличивается на 1 (если операция байтовая) или на 2. <br>`op_adr = r;`<br> `op_val = mem[op_adr];`<br>`r += 2 или 1; ` В случае `sp` или `pc` всегда `r += 2;`
|2|001111|`#nn`      |непосредственный (immediate)| Ассемблер помещает nn в ячейку ПОСЛЕ команды.  Используют для обозначения констант `#224`. После считывания инструкции `pc` указывает на `nn`<br>`op_adr = pc;`<br>`op_val = mem[op_adr]`<br>`pc += 2; `, то есть `nn;` `pc` указывает на следующую инструкцию|
|3|011rrr|`@(r)+`    |косвенный режим автоувеличения (auto-increment deferred)| `op_adr = mem[r];`<br>`op_val = mem[op_adr];`<br>`r += 2;` Значение регистра ВСЕГДА увеличивается на 2 вне зависимости от типа операции|
|3|011111|`@#nn`     |абсолютный (absolute)| берется число по указанному в `nn` адресу|
|4|100rrr|`–(r)`     |автоуменьшение (auto-decrement)|в регистре содержится адрес, еще ДО доступа к регистру его содержимое уменьшается на 1 (если операция байтовая) или на 2. <br>`r – = 2 или 1;`<br>`op_adr = r;`<br>`op_val = mem[r];` В случае `sp` или `pc` всегда `r –= 2;`|
|5|101rrr|`@–(r)`    |косвенный режим автоуменьшения (auto-decrement deferred)|`r – = 2;`<br>`op_adr = mem[r];`<br>`op_val = mem[op_adr];` Значение регистра ВСЕГДА уменьшается на 2 вне зависимости от типа операции|
|6|110rrr|`nn(r)`    |индексный (index)|Ассемблер кладет `nn` после инструкции.  Адресом является содержимое регистра и указанное число `nn`:<br> считываем `nn`, при этом сразу `pc+=2`<br>`op_adr = r;`<br>`pc += 2;`<br>`op_adr += nn;`<br>`op_val = mem[op_adr];` Содержимое регистра НЕ меняется.|
|6|101111|`nn`       |относительный (relative)|1) считываем инструкцию (`pc += 2`, указывает на `nn`)<br>2) считываем `nn`, при этом `pc += 2;`<br>3) `op_adr = pc;`<br>4) `op_adr += nn; op_val = mem[op_adr];`|
|7|111rrr|`@nn(r)`   |косвенный индексный (index deferred)|Извлекается nn при этом `pc += 2`<br>`op_adr = r;`<br>`op_adr += nn;`<br>`op_adr = mem[op_adr];`<br>`op_val = mem [ap_adr];`|
|7|111111|`@nn`      |косвенная относительная адресация (relative deferred)|Еще один уровень по сравнению с относительной:<br>1) считываем инструкцию (`pc += 2`, указывает на `nn`)<br>2) считываем `nn`, при этом `pc += 2;`<br>3) `op_adr = pc;`<br>4) `op_adr += nn; op_adr = mem[op_adr];`<br>5) `op_val = mem [ap_adr];`|
